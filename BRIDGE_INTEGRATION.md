# Holochain-OpenClaw Bridge Integration Guide

## Overview

This document outlines how to bridge Holochain zome calls to OpenClaw's TypeScript runtime for the hybrid ACP skill pack.

## Architecture

```
┌─────────────────┐         ┌──────────────────┐         ┌─────────────┐
│   OpenClaw      │◄────────┤  Bridge Layer    │◄────────┤  Holochain  │
│   (TypeScript)  │  WebSocket  (Node.js/Rust)  │   App WS  │   Conductor │
└─────────────────┘         └──────────────────┘         └─────────────┘
                                     │
                                     ▼
                            ┌─────────────────┐
                            │   Base L2 RPC   │
                            │  (ethers.rs)    │
                            └─────────────────┘
```

## Option 1: WebSocket Client (Recommended)

Use Holochain's App WebSocket interface from OpenClaw's TypeScript runtime.

### Advantages
- No native compilation required
- Works with existing OpenClaw plugin system
- Bidirectional async communication
- Signal support for job updates

### Implementation

1. **Holochain Conductor runs as separate process:**
   ```bash
   hc sandbox run -p 8888
   # or: hc run-local-services --bootstrap-url <url>
   ```

2. **OpenClaw plugin connects via WebSocket:**
   ```typescript
   import { AppWebsocket } from '@holochain/client';

   const client = await AppWebsocket.connect(`ws://localhost:8888`);
   const appInfo = await client.appInfo({ installed_app_id: 'holoclaw-acp' });
   
   // Call zome functions
   const agents = await client.callZome({
     cap_secret: null,
     cell_id: appInfo.cell_data[0].cell_id,
     zome_name: 'acp_coordinator',
     fn_name: 'browse_agents',
     payload: { query: 'trading' },
   });
   ```

3. **Hybrid Environment Handling:**
   - Store Holochain `agent_pubkey` in OpenClaw config
   - Keep existing `WALLET_PRIVATE_KEY` for Base L2 transactions
   - Bridge layer handles both identities

## Option 2: Neon FFI Binding

Use Neon to call Rust functions directly from Node.js.

### Advantages
- Lower latency (no network overhead)
- Single process deployment
- Native performance

### Disadvantages
- Requires native compilation
- More complex build process
- Platform-specific binaries

### Implementation Sketch

```rust
// In a separate neon-bridge crate
use neon::prelude::*;

fn browse_agents(mut cx: FunctionContext) -> JsResult<JsArray> {
    let query = cx.argument::<JsString>(0)?.value(&mut cx);
    // Call Holochain conductor via internal API
    // Return results as JS array
}

#[neon::main]
fn main(mut cx: ModuleContext) -> NeonResult<()> {
    cx.export_function("browseAgents", browse_agents)?;
    cx.export_function("executeAcpJob", execute_acp_job)?;
    cx.export_function("getWalletBalance", get_wallet_balance)?;
    Ok(())
}
```

## Option 3: Custom TypeScript Plugin Wrapper

Create a TypeScript plugin that manages both Holochain and Base interactions.

### Implementation

See `bridge/holoclaw_plugin.ts` for a complete example.

## Hybrid Environment Considerations

### Identity Management

You need to manage two separate identities:

1. **Holochain Agent PubKey:**
   - Generated by Holochain conductor
   - Used for DHT operations, signing entries
   - Stored in conductor's keystore

2. **Ethereum Wallet Private Key:**
   - Used for Base L2 transactions
   - Managed by OpenClaw/existing ACP system
   - Required for escrow and payments

### Recommended Approach

```typescript
interface HybridAgentConfig {
  // Holochain identity
  holochain: {
    agent_pubkey: HexString;      // From conductor
    conductor_url: string;         // e.g., 'ws://localhost:8888'
  };
  // Base L2 identity (existing)
  base: {
    wallet_address: string;        // 0x...
    private_key: string;           // 0x... (secure storage)
    session_key_id: number;        // ACP session key
  };
}
```

### Linking Identities

In the Holochain DHT, link your agent pubkey to your wallet address:

```rust
// When registering agent
let agent = AcpAgent {
    wallet_address: "0x...".to_string(),  // Your Base wallet
    session_key_id: 1,
    name: "My Agent".to_string(),
    // ...
};
register_agent(agent)?;
```

## Base L2 RPC Integration

The coordinator zome needs to query Base for balances and verify escrow transactions.

### Approach: External Service Bridge

Since Holochain WASM cannot make HTTP calls directly, use an external service:

1. **Create a Node.js service** (or Rust binary) that runs alongside conductor
2. **Expose JSON-RPC or WebSocket interface**
3. **Call from coordinator zome via capability grants or signals**

### Example: Balance Query Service

```typescript
// balance-service.ts
import express from 'express';
import { ethers } from 'ethers';

const app = express();
const provider = new ethers.JsonRpcProvider(process.env.BASE_RPC_URL);

app.get('/balance/:address', async (req, res) => {
  const balance = await provider.getBalance(req.params.address);
  res.json({
    address: req.params.address,
    balance_wei: balance.toString(),
    balance_eth: ethers.formatEther(balance),
  });
});

app.listen(3001);
```

Then from OpenClaw, call this service instead of the zome:

```typescript
// In OpenClaw plugin
async function getWalletBalance(address: string) {
  const response = await fetch(`http://localhost:3001/balance/${address}`);
  return response.json();
}
```

### Alternative: Use Holochain Signals

Emit signals from coordinator zome when balance is needed, handle in OpenClaw:

```rust
// In coordinator zome
emit_signal(Signal {
    data: ExternIO::encode(BalanceRequest { address }).unwrap(),
})?;
```

```typescript
// In OpenClaw, listen for signals
client.on('signal', async (signal) => {
  if (signal.type === 'balance_request') {
    const balance = await queryBaseRpc(signal.data.address);
    // Call back into Holochain with result
  }
});
```

## Testing the Bridge

### 1. Start Holochain Sandbox

```bash
cd /path/to/holoclaw-acp
hc sandbox clean
hc sandbox generate --directory=workdir holoclaw_acp
hc sandbox run -p 8888 workdir
```

### 2. Test from Node.js

```typescript
import { AppWebsocket } from '@holochain/client';

const client = await AppWebsocket.connect('ws://localhost:8888');
const result = await client.callZome({
  /* ... */
  fn_name: 'browse_agents',
  payload: { query: '' },
});
console.log('Agents:', result);
```

### 3. Integration Test with OpenClaw

Add to OpenClaw config:

```json
{
  "skills": {
    "entries": {
      "virtuals-protocol-acp": {
        "enabled": true,
        "env": {
          "HOLOCHAIN_CONDUCTOR_URL": "ws://localhost:8888",
          "HOLOCHAIN_INSTALLED_APP_ID": "holoclaw-acp",
          "BASE_RPC_URL": "https://mainnet.base.org",
          "WALLET_PRIVATE_KEY": "0x...",
          "AGENT_WALLET_ADDRESS": "0x...",
          "SESSION_ENTITY_KEY_ID": "1"
        }
      }
    }
  }
}
```

## Security Considerations

See `SECURITY.md` for detailed security guidelines.

## Next Steps

1. Implement WebSocket bridge in `bridge/holoclaw_plugin.ts`
2. Create external balance query service
3. Set up capability grants for external calls
4. Test with OpenClaw sandbox
5. Deploy conductor as systemd service or Docker container
